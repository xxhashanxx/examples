
#include <functional>
#include <iostream>

/*
rvalue references are one of the important features introduced by C++11 that are synonymous with
Lambda expressions. Its introduction solves a large number of historical issues in C++. Eliminating extra
overhead such as std::vector, std::string, and making the function object container std::function
possible.
*/
// lvalue, rvalue, prvalue, xvalue
/*
* lvalue, left value, as the name implies, is the value to the left of the assignment symbol. To be
precise, an lvalue is a persistent object that still exists after an expression (not necessarily an assignment expression).
* Rvalue, right value, the value on the right refers to the temporary object that no longer exists
after the expression ends.

**pvalue, pure rvalue, purely rvalue, either purely literal, such as 10, true; either the result of
the evaluation is equivalent to a literal or anonymous temporary object, for example 1+2. Temporary
variables returned by non-references, temporary variables generated by operation expressions, original
literals, and Lambda expressions are all pure rvalue values.
**Note that a literal (except a string literal) is a prvalue. However, a string literal is an lvalue with
type const char array.

**xvalue, expiring value is the concept proposed by C++11 to introduce rvalue references (so in
traditional C++, pure rvalue and rvalue are the same concepts), a value that is destroyed but can be
moved.



*/

#include <iostream>
#include <string>
void reference(std::string &str)
{
    std::cout << "lvalue" << std::endl;
}
void reference(std::string &&str)
{
    std::cout << "rvalue" << std::endl;
}
int main1()
{
    std::string lv1 = "string,"; // lv1 is a lvalue
    // std::string&& r1 = lv1; // illegal, rvalue can't ref to lvalue
    std::string &&rv1 = std::move(lv1); // legal, std::move can convert lvalue to rvalue
    std::cout << rv1 << std::endl;      // string,
    const std::string &lv2 = lv1 + lv1; // legal, const lvalue reference can
    // extend temp variable's lifecycle
    // lv2 += "Test"; // illegal, const ref can't be modified
    std::cout << lv2 << std::endl; // string,string,
    std::string &&rv2 = lv1 + lv2; // legal, rvalue ref extend lifecycle
    rv2 += "string";               // legal, non-const reference can be modified
    std::cout << rv2 << std::endl; // string,string,string,string
    reference(rv2);                // output: lvalue

    // int &a = std::move(1); // illegal, non-const lvalue reference cannot ref rvalue
    const int &b = std::move(1); // legal, const lvalue reference can
    std::cout << b << std::endl;

    return 0;
}

void increase(int &v)
{
    v++;
}
void foo()
{
    double s = 1;
    // increase(s); //illegal
}
///////////////////////////////////////////////////////////////
/*
void reference(int &v)
{
    std::cout << "lvalue reference" << std::endl;
}
void reference(int &&v)
{
    std::cout << "rvalue reference" << std::endl;
}
template <typename T>
void pass(T &&v)
{
    std::cout << " normal param passing: ";
    reference(v);
}
int main2()
{
    std::cout << "rvalue pass:" << std::endl;
    pass(1);
    std::cout << "lvalue pass:" << std::endl;
    int l = 1;
    pass(l);
    return 0;
}
*/
/*
Function parameter type | Argument parameter type | Post-derivation function parameter type
T&                          lvalue ref                  T&
T&                          rvalue ref                  T&
T&&                         lvalue ref                  T&
T&&                         rvalue ref                  T&&
*/

#include <utility>
void reference(int &v)
{
    std::cout << "lvalue reference" << std::endl;
}
void reference(int &&v)
{
    std::cout << "rvalue reference" << std::endl;
}
template <typename T>
void pass(T &&v)
{
    std::cout << " normal param passing: ";
    reference(v);
    std::cout << " std::move param passing: ";
    reference(std::move(v));
    std::cout << " std::forward param passing: ";
    reference(std::forward<T>(v));
    std::cout << "static_cast<T&&> param passing: ";
    reference(static_cast<T &&>(v));
}
int main()
{
    std::cout << "rvalue pass:" << std::endl;
    pass(1);
    std::cout << "lvalue pass:" << std::endl;
    int l = 1;
    pass(l);
    return 0;
}